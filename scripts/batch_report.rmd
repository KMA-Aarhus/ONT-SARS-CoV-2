---
title: "ONT SARS-CoV-2 batchsekventeringsrapport"
#subtitle: "KMA AUH"
#subtitle: "`r head(tail(unlist(strsplit(getwd(), "/")) ,2) ,1)`" # use the title variable from the pipeline instead somehow
#date: "generated at `r Sys.Date()`"
output:
  html_document:
    toc: False
    toc_depth: 2
  #prettydoc::html_pretty:
    #theme: cayman
    #highlight: github
editor_options: 
  chunk_output_type: console
  cache: True
#css: "max-width: 5000px; margin: auto; padding: 1em; line-height: 20px"
---
  
```{r echo=F, message=F, warning=F}
# Field variables and functions

library(tidyverse)

# Set develop to true if you want to develop locally
develop = F
if (develop) {
    #metadata_init = read_tsv("~/GenomeDK/clinmicrocore/pappenheim-receiver/output/20210521.1236/20210521.1236_metadata_init.tsv")
    #metadata_init = read_tsv("~/GenomeDK/clinmicrocore/pappenheim-receiver/output/20210611.1152/20210611.1152_metadata_init.tsv")
    
    setwd("~/GenomeDK/clinmicrocore/pappenheim-receiver/output/20210628.1153/")
    metadata_init = read_tsv("~/GenomeDK/clinmicrocore/pappenheim-receiver/output/20210628.1153/20210628.1153_metadata_init.tsv")
    
    
} else { # Normal duty
    metadata_init = read_tsv("metadata_init.tsv")
}

# Coalesce the ct-value - id 
#metadata_init = metadata_init %>% 
#    mutate(ct = coalesce(as.numeric(ct), as.numeric(ss_ct))) 
if (class(metadata_init$batch_id) == "numeric") {
metadata_init = metadata_init %>%  
    mutate(batch_id = sprintf("%.4f",round(batch_id,4)))
}
batch_id = metadata_init$batch_id %>% unique


# A function that returns a new table number for each run
tableno_var = 0
tableno = function() {
    tableno_var <<- tableno_var + 1
    tableno_var
}
figno_var = 0
figno = function() {
    figno_var <<- figno_var + 1
    figno_var
}
```

  
```{r echo=F, message=F, warning=F}




# 
# not_full_width = function(input, ...) {
#     #kableExtra::kable_styling(input, full_width = F, position = "left", ...)
#     kableExtra::kable_styling(input, full_width = F)
# }

```

## Batch `r paste(batch_id)`

#### KMA AUH

------



```{r echo=F, message=F, warning=F}

metadata_init %>% 
    group_by(batch_id, very_long_batch_id, batch_sum_reads, batch_unclassified_reads, batch_unclassified_reads_prop, batch_hours_sequencing, batch_million_reads_per_day, batch_control_stamp, batch_control_error_messages) %>% 
    summarize(plates = paste(rack_id %>% unique, collapse = ", ")) %>% 
    ungroup() %>% 
    separate(very_long_batch_id, c("date", "time", "minion", "flowcell", "arbhash"), sep = "_", remove = T) %>%
    #mutate_at(dplyr::select(where(is.numeric)), round) %>% #
    mutate_at(vars(batch_unclassified_reads_prop, batch_hours_sequencing, batch_million_reads_per_day), round, digits = 2) %>% 
    mutate_all(as.character) %>% 
    pivot_longer(everything()) %>%
    knitr::kable()
```

*Tabel `r tableno()`: Overordnet statistik.*


```{r echo=F, message=F, warning=F}

metadata_init %>% 
    group_by(type) %>% 
    summarize(count = length(type)) %>%  
    ungroup() %>% 
    arrange(desc(count)) %>% 
    knitr::kable() #%>% 
    #not_full_width()

```

*Tabel `r tableno()`: Antal prøver per kontroltype.*


```{r echo=F, message=F, warning=F}

metadata_init %>% 
    
    mutate(mads_type = case_when(type == "sample" ~ str_sub(ya_sample_id, 1, 1), # Insert the sample type letter into the table.
                                 TRUE ~ ""),
           pa_note = case_when(grepl("scorpio", pa_note) ~ "",
                                is.na(pa_note) ~ "",
                                TRUE ~ pa_note),
           pa_note = str_replace_all(pa_note, ":", "=")) %>% 
    select(barcode, type, mads_type, pa_lineage, pa_note, `totalMissing` = ne_totalMissing_interpreted, `numberOfReads` = ba_reads, ct, ) %>% 
    knitr::kable()

```
*Tabel `r tableno()`: Prøvelisteoversigt. For flere informationer (fx. prøvenumre) henvises til `~/clinmicrocore/pappenheim-receiver/output/metadata_init.tsv` på GenomeDK.*


```{r echo=F, message=F, warning=F, fig.height = 3, fig.width = 7, cache=TRUE}

metadata_init %>% 
    group_by(pa_lineage, type) %>% 
    #summarize(count = length(type), `type(s)` = paste(type %>% table %>% as_tibble %>%  format_delim(delim = " "), collapse = " ")) %>% 
    summarize(count = length(pa_lineage)) %>% 
    arrange(desc(count)) %>% 
    knitr::kable() #%>% 
    #not_full_width()


```
*Tabel `r tableno()`: Fordeling af Pangolin lineage kald på prøve-typer. Den positive kontrol bør altid få det samme lineage kald på tværs af sekventeringsbatches.*




Genomer er rekonstrueret lokalt på sekventeringsworkstations med [artic minion](https://artic.network/ncov-2019/ncov2019-bioinformatics-sop.html).

```{r echo=F, message=F, warning=F, fig.height = 3, fig.width = 7}

metadata_init %>% 
    mutate(rank = row_number(ne_totalMissing_interpreted)) %>% 
    
    ggplot(aes(rank, ne_totalMissing_interpreted, color = type)) + 
    geom_hline(yintercept = 29904/2, color = rgb(248/255, 118/255, 109/255), linetype = "dashed", alpha = 0.8) +
    geom_hline(yintercept = 3000, color = rgb(0, 186/255, 59/255), linetype = "dashed", alpha = 0.8) +
    geom_line(alpha = 0.2, color = "black") + 
    geom_point() + 

    labs(x = "samples\n(ordered by increasing totalMissing)", 
         y = "totalMissing")
```

*Fig `r figno()`: Rankering af antal manglende baser i rekonstruerede genomer (totalMissing). Beregnet med Nextclade. De stiplede linjer (grøn = 3000, rød = 15000) viser kvalitetskontroltærsklerne for de positive og negative kontroller, henholdsvist.*




```{r echo=F, message=F, warning=F, fig.height = 3, fig.width = 5.5}

# Ordered as they should be listed.
mycolors <- c("HQ"= rgb(0/255, 186/255, 56/255), "MQ"=rgb(97/255, 156/255, 255/255), "LQ" = rgb(248/255, 118/255, 109/255))

metadata_init %>% 
    mutate(row_number_raw = seq(0, length(.$full_name)-1),
           
           axis_1 = (row_number_raw) %% 8,
           axis_1 = axis_1 + 1,
           axis_1 = letters[axis_1] %>% toupper(),
           
           axis_2 = row_number_raw %/% 8,
           axis_2 = axis_2 + 1) %>% 
    
    mutate(annotation_type_letter = case_when(type == "positive_control" ~ "PC", 
                                  type == "negative_control" ~ "NC",
                                  TRUE ~ ""),
           annotation_quality = case_when(ne_totalMissing_interpreted <= 130 ~ "HQ",
                                          ne_totalMissing_interpreted <= 3000 ~ "MQ",
                                          TRUE <= 15000 ~ "LQ"),
           annotation_quality = factor(annotation_quality, levels = names(mycolors))) %>% 

    select(starts_with("axis_"), everything()) %>% 
    bind_rows(tibble(axis_1 = letters[(seq(0,11)%%8)+1] %>% toupper(), axis_2 = 1:12)) %>% 
    #bind_rows(tibble(axis_2 = 1:12)) %>% View
    
    
    ggplot(aes(factor(axis_2), reorder(factor(axis_1), desc(axis_1)), fill = annotation_quality)) + 
    scale_fill_manual(values=mycolors) +
    geom_tile() + 
    geom_text(aes(label = annotation_type_letter), color = "white") + 
    labs(x = "",
         y = "",
         fill = "genome\nquality") + 
    scale_x_discrete(breaks = 1:12)

```

*Fig `r figno()`: Pladeoversigt med farvning efter kvalitet (totalMissing). HQ har <= 130 totalMissing, MQ har <= 3000 totalMissing, LQ har > 3000 totalMissing). `PC` og `NC` indikerer positive- og negative kontroller, henholdsvist.*



------

### PCR-produkt
```{r echo=F, message=F, warning=F, fig.height = 4, fig.width = 7, cache=TRUE}


na_text = paste(paste(metadata_init$ct %>% is.na %>% sum), "prøver mangler angivelse af Mads Ct-værdi.")

metadata_init %>% 
    ggplot(aes(as.numeric(ct), as.numeric(`qubit_ng/ul`), color = type)) + 
    geom_smooth(method = "lm", se = T) +
    geom_point() + 
    labs(
         x = "Mads Ct", 
         y = "qubit ng/\u03bcl",
         caption = na_text) +
    
    scale_x_continuous(#breaks = seq(16, 36), 
                       minor_breaks = 1:100) 

```

*Fig. `r figno()`: Forhold mellem bibliotekskoncentration og Ct-værdi. En lineær regressionslinje er vist. Bemærk at prøver uden Ct-værdi ikke er vist.*





```{r echo=F, message=F, warning=F, fig.height = 4, fig.width = 7, cache=TRUE}

na_text = paste(paste(metadata_init$ct %>% is.na %>% sum), "prøver mangler angivelse af Mads Ct-værdi.")


log_10_breaks = c(1, 10, 100, 1000, 10000, 30000)
metadata_init %>% 
    mutate(ne_totalMissing_interpreted = as.numeric(ne_totalMissing_interpreted)) %>% 
    ggplot(aes(ct, ne_totalMissing_interpreted, color = type)) + 
    geom_hline(yintercept = 29903/2, color = rgb(248/255, 118/255, 109/255), linetype = "dashed", alpha = 0.8) +
    geom_hline(yintercept = 3000, color = rgb(0, 186/255, 59/255), linetype = "dashed", alpha = 0.8) +
    #geom_smooth(method = "glm", method.args = list(family = "binomial"), se = F) + 
    geom_smooth(method = "lm") +
    geom_point() +
    labs(x = "Mads Ct", 
         y = "",
         caption = na_text) +
    #coord_trans(y = "log10") 

    # scale_y_log10(breaks = seq(0, 1, 0.25), 
    #               #labels = c("0", "7500", "15000", "22500", "30000"),
    #               labels = as.character(seq(0, 29904, 29904/4))) +
    
    scale_y_log10(breaks = log_10_breaks,
                  minor_breaks = log_10_breaks[1:4] * 5
                  ) +
    
    scale_x_continuous(#breaks = seq(16, 36), 
                       minor_breaks = 1:100) 




```


*Fig. `r figno()`: Forhold mellem manglende baser i de rekonstruerede genomer og deres Ct-værdi Bemærk at den lodrette akse visuelt er logaritmetransformeret (log10). En lineær regressionlinje efter de transformerede punkter er vist. Bemærk, at kun de prøver som har en Ct-værdi angivet, er vist i figuren. Den grønne og røde stiplede linje viser kvalitetskontroltærsklerne for 3000 baser og 15000 baser, henholdsvist.*



```{r echo=FALSE, message=F, warning=F}
try({
    # This chunk is needed for setting the size of the following plot.
    fig_height = max(3,
                    (metadata_init %>% filter(!str_detect(pa_taxon, "notenoughdata")) %>% nrow()) * 1)
    
    knitr::opts_chunk$set(fig.height = fig_height,
                          fig.width = 10)
})
```


```{r depth, echo=F, message=F, warning=F}



depths_file = paste0("../scripts/depths.tsv")

primer_scheme_file = "../artic-ncov2019/primer_schemes/nCoV-2019/V3/nCoV-2019.primer.bed" 
# VarSkip_short/nCoV-2019.primer.bed" #VarSkip short primers

if(file.exists(depths_file) & file.exists(primer_scheme_file)) {
    write(paste("depths and primer files exist"), stderr())
    depths_df = read_tsv(depths_file, col_names = c("full_name", "record", "scheme", "position", "depth")) %>% 
        left_join(metadata_init %>% select(full_name, barcode, type), by = "full_name") %>% 
        mutate(text = paste0(barcode, "\n", type))
 
    
    
    
    primer_scheme = read_tsv(primer_scheme_file,
                             col_names = c("record", "start", "end", "name", "pair", "strand")) %>% 
        separate(name, into = c("species", "primer_id", "hand", "alt"), sep = "_") %>% 
        filter(is.na(alt)) # We don't care about the alternative primers right now.
    
    primer_scheme_names = primer_scheme %>% 
        select(primer_id, start, end, hand) %>%
        mutate(primer_id = as.numeric(primer_id)) %>% 
        group_by(primer_id) %>% 
        summarize(pos = mean(c(start, end))) %>% 
        
        # Filter for only a subset of names.
        filter(primer_id == 1 | primer_id == 98 | primer_id %% 5 == 0)
        
    
    
    
    #primer_scheme %>% 
        #select(primer_id, hand, start, end) %>% View
        #pivot_wider(id_cols = primer_id, names_from = hand, values_from = hand) %>% 
        
        #View
    # ggplot() + 
    #     geom_vline(aes(xintercept = start), data = primer_scheme, color = "blue" , alpha = 0.3, size = 0.2) + 
    #     geom_vline(aes(xintercept = end), data = primer_scheme, color = "red", alpha = 0.3, size = 0.2)
        
    
    
    vline_color = "grey50"
    vline_size = 0.1
    vline_alpha = 1
    
plot_depth = depths_df %>%
        group_by(text, position) %>%
        summarize(depth = max(depth)) %>%
        
        mutate(above_20x = case_when(depth >= 20 ~ T, 
                                     TRUE ~ F)) %>% 
        
        ggplot() + 
        
        # Primer lines
        geom_vline(aes(xintercept = start), data = primer_scheme, color = "grey75", size = vline_size, alpha = vline_alpha) + 
        geom_vline(aes(xintercept = end), data = primer_scheme, color = "grey75", size = vline_size, alpha = vline_alpha) +
    
        # Depth
        geom_point(aes(position, depth, color = above_20x), size = 0.05, alpha = 0.7) + 
        
        theme_bw() +
    
        ylim(0,400) +
        scale_x_continuous(breaks = primer_scheme_names$pos,
                           labels = primer_scheme_names$primer_id) +
        theme(panel.grid.major.x = element_blank(),
              panel.grid.minor.x = element_blank(),
              panel.grid.minor.y = element_blank(), 
              legend.position = "None") +
        facet_grid(text~.) +
    labs(x = "amplicon #")
    
    
ggsave(paste0(batch_id, "_depths.pdf"), plot = plot_depth, height = fig_height, width = 12)

plot_depth
        
    
    
    

} else {
    warning(paste("The depth-figure is not generated, because the depth-file and primer scheme must be present.", batch_id))
}


```



*Fig. `r figno()`: Dybde for hver nukleotid over alle genomer. Turkis indikerer at dækningen er over 20x, rød indikerer at dækningen er under 20x. Kun prøver, hvor read-mappingen blev gennemført er vist. Dybden er kun målt op til 400x.*





------


Denne rapport er en del af pappenheim-receiver pipelinen som er udviklet på KMA, AUH.
